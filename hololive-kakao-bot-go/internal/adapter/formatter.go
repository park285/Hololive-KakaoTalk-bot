package adapter

import (
	"fmt"
	"strings"

	"github.com/kapu/hololive-kakao-bot-go/internal/constants"
	"github.com/kapu/hololive-kakao-bot-go/internal/domain"
	"github.com/kapu/hololive-kakao-bot-go/internal/util"
)

// AlarmListEntry represents a single alarm item for formatting.
type AlarmListEntry struct {
	MemberName string
	NextStream string
}

// ResponseFormatter formats bot responses
type ResponseFormatter struct {
	prefix string
}

// NewResponseFormatter creates a new ResponseFormatter
func NewResponseFormatter(prefix string) *ResponseFormatter {
	if strings.TrimSpace(prefix) == "" {
		prefix = "!"
	}
	return &ResponseFormatter{prefix: prefix}
}

// FormatLiveStreams formats live streams into a message
func (f *ResponseFormatter) FormatLiveStreams(streams []*domain.Stream) string {
	if len(streams) == 0 {
		return "üî¥ ÌòÑÏû¨ Î∞©ÏÜ° Ï§ëÏù∏ Ïä§Ìä∏Î¶ºÏù¥ ÏóÜÏäµÎãàÎã§."
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("üî¥ ÌòÑÏû¨ ÎùºÏù¥Î∏å Ï§ë (%dÍ∞ú)\n\n", len(streams)))

	for i, stream := range streams {
		if i > 0 {
			sb.WriteString("\n")
		}

		title := f.truncateTitle(stream.Title)

		sb.WriteString(fmt.Sprintf("üì∫ %s\n", stream.ChannelName))
		sb.WriteString(fmt.Sprintf("   %s\n", title))
		sb.WriteString(fmt.Sprintf("   %s", stream.GetYouTubeURL()))

		if i < len(streams)-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// FormatUpcomingStreams formats upcoming streams into a message
func (f *ResponseFormatter) FormatUpcomingStreams(streams []*domain.Stream, hours int) string {
	if len(streams) == 0 {
		return fmt.Sprintf("üìÖ %dÏãúÍ∞Ñ Ïù¥ÎÇ¥ ÏòàÏ†ïÎêú Î∞©ÏÜ°Ïù¥ ÏóÜÏäµÎãàÎã§.", hours)
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("üìÖ ÏòàÏ†ïÎêú Î∞©ÏÜ° (%dÏãúÍ∞Ñ Ïù¥ÎÇ¥, %dÍ∞ú)\n\n", hours, len(streams)))

	for i, stream := range streams {
		if i > 0 {
			sb.WriteString("\n")
		}

		title := f.truncateTitle(stream.Title)
		timeInfo := f.formatStreamTimeInfo(stream)

		sb.WriteString(fmt.Sprintf("üì∫ %s\n", stream.ChannelName))
		sb.WriteString(fmt.Sprintf("   %s\n", title))
		sb.WriteString(fmt.Sprintf("   ‚è∞ %s\n", timeInfo))
		sb.WriteString(fmt.Sprintf("   %s", stream.GetYouTubeURL()))

		if i < len(streams)-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// FormatChannelSchedule formats channel schedule into a message
func (f *ResponseFormatter) FormatChannelSchedule(channel *domain.Channel, streams []*domain.Stream, days int) string {
	if channel == nil {
		return "‚ùå Ï±ÑÎÑê Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
	}

	channelName := channel.GetDisplayName()

	if len(streams) == 0 {
		return fmt.Sprintf("üìÖ %s\n%dÏùº Ïù¥ÎÇ¥ ÏòàÏ†ïÎêú Î∞©ÏÜ°Ïù¥ ÏóÜÏäµÎãàÎã§.", channelName, days)
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("üìÖ %s ÏùºÏ†ï (%dÏùº Ïù¥ÎÇ¥, %dÍ∞ú)\n\n", channelName, days, len(streams)))

	for i, stream := range streams {
		if i > 0 {
			sb.WriteString("\n")
		}

		title := f.truncateTitle(stream.Title)

		var statusIcon string
		var timeInfo string

		if stream.IsLive() {
			statusIcon = "üî¥ LIVE"
			timeInfo = "ÏßÄÍ∏à Î∞©ÏÜ° Ï§ë"
		} else {
			statusIcon = "‚è∞"
			timeInfo = f.formatStreamTimeInfo(stream)
		}

		sb.WriteString(fmt.Sprintf("%s %s\n", statusIcon, title))
		sb.WriteString(fmt.Sprintf("   %s\n", timeInfo))
		sb.WriteString(fmt.Sprintf("   %s", stream.GetYouTubeURL()))

		if i < len(streams)-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// FormatAlarmAdded formats alarm added confirmation
func (f *ResponseFormatter) FormatAlarmAdded(memberName string, added bool, nextStreamInfo string) string {
	if !added {
		return fmt.Sprintf("‚ÑπÔ∏è %s ÏïåÎûåÏù¥ Ïù¥ÎØ∏ ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏäµÎãàÎã§.", memberName)
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("‚úÖ %s ÏïåÎûåÏù¥ ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§!\n\n", memberName))
	if nextStreamInfo != "" {
		sb.WriteString(nextStreamInfo)
		if !strings.HasSuffix(nextStreamInfo, "\n") {
			sb.WriteString("\n")
		}
		sb.WriteString("\n")
	}
	sb.WriteString("Î∞©ÏÜ° ÏãúÏûë 5Î∂Ñ Ï†ÑÏóê ÏïåÎ¶ºÏùÑ Î∞õÏäµÎãàÎã§.\n")
	sb.WriteString(fmt.Sprintf("%sÏïåÎûå Î™©Î°ù ÏúºÎ°ú ÌôïÏù∏ Í∞ÄÎä•Ìï©ÎãàÎã§.", f.prefix))
	return sb.String()
}

// FormatAlarmRemoved formats alarm removed confirmation
func (f *ResponseFormatter) FormatAlarmRemoved(memberName string, removed bool) string {
	if removed {
		return fmt.Sprintf("‚úÖ %s ÏïåÎûåÏù¥ Ìï¥Ï†úÎêòÏóàÏäµÎãàÎã§.", memberName)
	}
	return fmt.Sprintf("‚ùå %s ÏïåÎûåÏù¥ ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.", memberName)
}

// FormatAlarmList formats user's alarm list
func (f *ResponseFormatter) FormatAlarmList(alarms []AlarmListEntry) string {
	if len(alarms) == 0 {
		return fmt.Sprintf("üîî ÏÑ§Ï†ïÎêú ÏïåÎûåÏù¥ ÏóÜÏäµÎãàÎã§.\n\nüí° ÏÇ¨Ïö©Î≤ï:\n%sÏïåÎûå Ï∂îÍ∞Ä [Î©§Î≤ÑÎ™Ö]\nÏòà) %sÏïåÎûå Ï∂îÍ∞Ä ÌéòÏΩîÎùº\nÏòà) %sÏïåÎûå Ï∂îÍ∞Ä ÎØ∏ÏΩî",
			f.prefix, f.prefix, f.prefix)
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("üîî ÏÑ§Ï†ïÎêú ÏïåÎûå (%dÍ∞ú)\n\n", len(alarms)))

	for idx, alarm := range alarms {
		sb.WriteString(fmt.Sprintf("%d. %s\n", idx+1, alarm.MemberName))
		if strings.TrimSpace(alarm.NextStream) != "" {
			sb.WriteString(fmt.Sprintf("   %s\n", alarm.NextStream))
		}
		sb.WriteString("\n")
	}

	sb.WriteString(fmt.Sprintf("üí° %sÏïåÎûå Ï†úÍ±∞ [Î©§Î≤ÑÎ™Ö] ÏúºÎ°ú ÏïåÎûå Ìï¥Ï†ú", f.prefix))
	return strings.TrimSuffix(sb.String(), "\n")
}

// FormatAlarmCleared formats all alarms cleared confirmation
func (f *ResponseFormatter) FormatAlarmCleared(count int) string {
	if count == 0 {
		return "ÏÑ§Ï†ïÎêú ÏïåÎûåÏù¥ ÏóÜÏäµÎãàÎã§."
	}
	return fmt.Sprintf("‚úÖ %dÍ∞úÏùò ÏïåÎûåÏù¥ Î™®Îëê Ìï¥Ï†úÎêòÏóàÏäµÎãàÎã§.", count)
}

// FormatAlarmNotification formats alarm notification message
func (f *ResponseFormatter) FormatAlarmNotification(channel *domain.Channel, stream *domain.Stream, minutesUntil int, users []string) string {
	channelName := channel.GetDisplayName()

	title := util.TruncateString(stream.Title, constants.StringLimits.StreamTitle)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("üîî %s Î∞©ÏÜ° ÏïåÎ¶º\n\n", channelName))

	if minutesUntil > 0 {
		sb.WriteString(fmt.Sprintf("‚è∞ %dÎ∂Ñ ÌõÑ ÏãúÏûë ÏòàÏ†ï\n", minutesUntil))
	} else {
		sb.WriteString("‚è∞ Í≥ß ÏãúÏûëÌï©ÎãàÎã§!\n")
	}

	sb.WriteString(fmt.Sprintf("üì∫ %s\n\n", title))
	sb.WriteString(fmt.Sprintf("%s", stream.GetYouTubeURL()))

	if len(users) > 0 {
		sb.WriteString(fmt.Sprintf("\n\nÏïåÎ¶º ÎåÄÏÉÅ: %dÎ™Ö", len(users)))
	}

	return sb.String()
}

// FormatHelp formats help message
func (f *ResponseFormatter) FormatHelp() string {
	p := f.prefix
	return fmt.Sprintf(`üå∏ ÌôÄÎ°úÎùºÏù¥Î∏å Ïπ¥Ïπ¥Ïò§ÌÜ° Î¥á

üì∫ Î∞©ÏÜ° ÌôïÏù∏
  %sÎùºÏù¥Î∏å - ÌòÑÏû¨ ÎùºÏù¥Î∏å Ï§ëÏù∏ Î∞©ÏÜ°
  %sÎùºÏù¥Î∏å [Î©§Î≤ÑÎ™Ö] - ÌäπÏ†ï Î©§Î≤Ñ ÎùºÏù¥Î∏å ÌôïÏù∏
  %sÏòàÏ†ï [ÏãúÍ∞Ñ] - ÏòàÏ†ïÎêú Î∞©ÏÜ° (Í∏∞Î≥∏ 24ÏãúÍ∞Ñ)
  %sÎ©§Î≤Ñ [Ïù¥Î¶Ñ] [ÏùºÏàò] - ÌäπÏ†ï Î©§Î≤Ñ ÏùºÏ†ï (Í∏∞Î≥∏ 7Ïùº)

üë§ Î©§Î≤Ñ Ï†ïÎ≥¥
  %sÏ†ïÎ≥¥ [Î©§Î≤ÑÎ™Ö] - Î©§Î≤Ñ ÌîÑÎ°úÌïÑ Ï°∞Ìöå
  Ïòà: "%sÎØ∏ÏΩî Ï†ïÎ≥¥", "%sÏïÑÏø†ÏïÑÏóê ÎåÄÌï¥ ÏïåÎ†§Ï§ò"

üîî ÏïåÎûå ÏÑ§Ï†ï
  %sÏïåÎûå Ï∂îÍ∞Ä [Î©§Î≤ÑÎ™Ö]
  %sÏïåÎûå Ï†úÍ±∞ [Î©§Î≤ÑÎ™Ö]
  %sÏïåÎûå Î™©Î°ù
  %sÏïåÎûå Ï¥àÍ∏∞Ìôî

üí¨ ÏûêÏó∞Ïñ¥ ÏßÄÏõê
  Ïòà: "%sÌéòÏΩîÎùº ÏùºÏ†ï ÏïåÎ†§Ï§ò", "%sÏßÄÍ∏à Î∞©ÏÜ°ÌïòÎäî ÏÇ¨Îûå ÏûàÏñ¥?"

‚ù§Ô∏è Made with love for Hololive fans`, p, p, p, p, p, p, p, p, p, p, p, p, p)
}

// FormatError formats error message
func (f *ResponseFormatter) FormatError(message string) string {
	return fmt.Sprintf("‚ùå %s", message)
}

// FormatMemberNotFound formats member not found error
func (f *ResponseFormatter) FormatMemberNotFound(memberName string) string {
	return f.FormatError(fmt.Sprintf("'%s' Î©§Î≤ÑÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", memberName))
}

// FormatTalentProfile formats official talent profile data into a readable message.
func (f *ResponseFormatter) FormatTalentProfile(raw *domain.TalentProfile, translated *domain.TranslatedTalentProfile) string {
	if raw == nil {
		return "‚ùå ÌîÑÎ°úÌïÑ Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
	}

	var sb strings.Builder

	displayName := raw.EnglishName
	if translated != nil && strings.TrimSpace(translated.DisplayName) != "" {
		displayName = translated.DisplayName
	}

	sb.WriteString(fmt.Sprintf("üìò %s", displayName))
	if raw.JapaneseName != "" {
		sb.WriteString(fmt.Sprintf(" (%s)", raw.JapaneseName))
	}
	sb.WriteString("\n")

	catchphrase := strings.TrimSpace(raw.Catchphrase)
	if translated != nil && strings.TrimSpace(translated.Catchphrase) != "" {
		catchphrase = translated.Catchphrase
	}
	if catchphrase != "" {
		sb.WriteString(fmt.Sprintf("üó£Ô∏è %s\n", catchphrase))
	}

	summary := ""
	if translated != nil && strings.TrimSpace(translated.Summary) != "" {
		summary = translated.Summary
	} else if raw.Description != "" {
		summary = raw.Description
	}
	if summary != "" {
		sb.WriteString(summary)
		sb.WriteString("\n")
	}

	if translated != nil && len(translated.Highlights) > 0 {
		sb.WriteString("\n‚ú® ÌïòÏù¥ÎùºÏù¥Ìä∏\n")
		for _, highlight := range translated.Highlights {
			trimmed := strings.TrimSpace(highlight)
			if trimmed == "" {
				continue
			}
			sb.WriteString(fmt.Sprintf("- %s\n", trimmed))
		}
	}

	dataEntries := make([]domain.TranslatedProfileDataRow, 0)
	if translated != nil && len(translated.Data) > 0 {
		dataEntries = translated.Data
	} else {
		for _, entry := range raw.DataEntries {
			if strings.TrimSpace(entry.Label) == "" || strings.TrimSpace(entry.Value) == "" {
				continue
			}
			dataEntries = append(dataEntries, domain.TranslatedProfileDataRow{
				Label: entry.Label,
				Value: entry.Value,
			})
		}
	}

	if len(dataEntries) > 0 {
		sb.WriteString("\nüìã ÌîÑÎ°úÌïÑ Îç∞Ïù¥ÌÑ∞\n")
		maxRows := len(dataEntries)
		if maxRows > 8 {
			maxRows = 8
		}
		for i := 0; i < maxRows; i++ {
			row := dataEntries[i]
			if strings.TrimSpace(row.Label) == "" || strings.TrimSpace(row.Value) == "" {
				continue
			}
			sb.WriteString(fmt.Sprintf("- %s: %s\n", row.Label, row.Value))
		}
	}

	if len(raw.SocialLinks) > 0 {
		sb.WriteString("\nüîó ÎßÅÌÅ¨\n")
		maxLinks := len(raw.SocialLinks)
		if maxLinks > 4 {
			maxLinks = 4
		}
		for i := 0; i < maxLinks; i++ {
			link := raw.SocialLinks[i]
			if strings.TrimSpace(link.Label) == "" || strings.TrimSpace(link.URL) == "" {
				continue
			}
			sb.WriteString(fmt.Sprintf("- %s: %s\n", link.Label, link.URL))
		}
	}

	if raw.OfficialURL != "" {
		sb.WriteString("\nüåê Í≥µÏãù ÌîÑÎ°úÌïÑ: ")
		sb.WriteString(raw.OfficialURL)
	}

	return strings.TrimSpace(sb.String())
}

// Helper methods

// truncateTitle truncates a title to the maximum length
func (f *ResponseFormatter) truncateTitle(title string) string {
	return util.TruncateString(title, constants.StringLimits.StreamTitle)
}

// formatStreamTimeInfo formats stream time information
func (f *ResponseFormatter) formatStreamTimeInfo(stream *domain.Stream) string {
	if stream == nil || stream.StartScheduled == nil {
		return "ÏãúÍ∞Ñ ÎØ∏Ï†ï"
	}

	// Convert to KST
	kstTime := util.FormatKST(*stream.StartScheduled, "01/02 15:04")
	minutesUntil := stream.MinutesUntilStart()

	if minutesUntil <= 0 {
		return kstTime
	}

	hoursUntil := minutesUntil / 60
	minutesRem := minutesUntil % 60

	if hoursUntil > 24 {
		daysUntil := hoursUntil / 24
		return fmt.Sprintf("%s (%dÏùº ÌõÑ)", kstTime, daysUntil)
	} else if hoursUntil > 0 {
		return fmt.Sprintf("%s (%dÏãúÍ∞Ñ %dÎ∂Ñ ÌõÑ)", kstTime, hoursUntil, minutesRem)
	} else {
		return fmt.Sprintf("%s (%dÎ∂Ñ ÌõÑ)", kstTime, minutesRem)
	}
}
