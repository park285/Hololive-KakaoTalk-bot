package adapter

import (
	"fmt"
	"strings"

	"github.com/kapu/hololive-kakao-bot-go/internal/constants"
	"github.com/kapu/hololive-kakao-bot-go/internal/domain"
	"github.com/kapu/hololive-kakao-bot-go/internal/util"
)

type AlarmListEntry struct {
	MemberName string
	NextStream string
}

type ResponseFormatter struct {
	prefix string
}

type liveStreamView struct {
	ChannelName string
	Title       string
	URL         string
}

type liveStreamsTemplateData struct {
	Count   int
	Streams []liveStreamView
}

type upcomingStreamView struct {
	ChannelName string
	Title       string
	TimeInfo    string
	URL         string
}

type upcomingStreamsTemplateData struct {
	Count   int
	Hours   int
	Streams []upcomingStreamView
}

type scheduleEntryView struct {
	StatusIcon string
	Title      string
	TimeInfo   string
	URL        string
}

type channelScheduleTemplateData struct {
	ChannelName string
	Days        int
	Count       int
	Streams     []scheduleEntryView
}

type alarmAddedTemplateData struct {
	MemberName string
	Added      bool
	NextInfo   string
	Prefix     string
}

type alarmRemovedTemplateData struct {
	MemberName string
	Removed    bool
}

type alarmListTemplateData struct {
	Count  int
	Prefix string
	Alarms []AlarmListEntry
}

type alarmClearedTemplateData struct {
	Count int
}

type alarmNotificationTemplateData struct {
	ChannelName  string
	MinutesUntil int
	Title        string
	URL          string
}

type helpTemplateData struct {
	Prefix string
}

func NewResponseFormatter(prefix string) *ResponseFormatter {
	if strings.TrimSpace(prefix) == "" {
		prefix = "!"
	}
	return &ResponseFormatter{prefix: prefix}
}

func (f *ResponseFormatter) FormatLiveStreams(streams []*domain.Stream) string {

	data := liveStreamsTemplateData{Count: len(streams)}
	if len(streams) > 0 {
		data.Streams = make([]liveStreamView, len(streams))
		for i, stream := range streams {
			data.Streams[i] = liveStreamView{
				ChannelName: stream.ChannelName,
				Title:       f.truncateTitle(stream.Title),
				URL:         stream.GetYouTubeURL(),
			}
		}
	}

	if rendered, err := executeFormatterTemplate("live_streams.tmpl", data); err == nil {
		return rendered
	}

	return f.fallbackLiveStreams(data)
}

func (f *ResponseFormatter) FormatUpcomingStreams(streams []*domain.Stream, hours int) string {

	data := upcomingStreamsTemplateData{Count: len(streams), Hours: hours}
	if len(streams) > 0 {
		data.Streams = make([]upcomingStreamView, len(streams))
		for i, stream := range streams {
			data.Streams[i] = upcomingStreamView{
				ChannelName: stream.ChannelName,
				Title:       f.truncateTitle(stream.Title),
				TimeInfo:    f.formatStreamTimeInfo(stream),
				URL:         stream.GetYouTubeURL(),
			}
		}
	}

	if rendered, err := executeFormatterTemplate("upcoming_streams.tmpl", data); err == nil {
		return rendered
	}

	return f.fallbackUpcomingStreams(data)
}

func (f *ResponseFormatter) FormatChannelSchedule(channel *domain.Channel, streams []*domain.Stream, days int) string {

	data := channelScheduleTemplateData{Days: days, Count: len(streams)}
	if channel != nil {
		data.ChannelName = channel.GetDisplayName()
	}
	if len(streams) > 0 {
		data.Streams = make([]scheduleEntryView, len(streams))
		for i, stream := range streams {
			entry := scheduleEntryView{
				Title: f.truncateTitle(stream.Title),
				URL:   stream.GetYouTubeURL(),
			}

			if stream.IsLive() {
				entry.StatusIcon = "üî¥ LIVE"
				entry.TimeInfo = "ÏßÄÍ∏à Î∞©ÏÜ° Ï§ë"
			} else {
				entry.StatusIcon = "‚è∞"
				entry.TimeInfo = f.formatStreamTimeInfo(stream)
			}

			data.Streams[i] = entry
		}
	}

	if rendered, err := executeFormatterTemplate("channel_schedule.tmpl", data); err == nil {
		return rendered
	}

	return f.fallbackChannelSchedule(data)
}

func (f *ResponseFormatter) FormatAlarmAdded(memberName string, added bool, nextStreamInfo string) string {

	data := alarmAddedTemplateData{
		MemberName: memberName,
		Added:      added,
		NextInfo:   strings.TrimSpace(nextStreamInfo),
		Prefix:     f.prefix,
	}

	if rendered, err := executeFormatterTemplate("alarm_added.tmpl", data); err == nil {
		return rendered
	}

	return f.fallbackAlarmAdded(data)
}

func (f *ResponseFormatter) FormatAlarmRemoved(memberName string, removed bool) string {

	data := alarmRemovedTemplateData{
		MemberName: memberName,
		Removed:    removed,
	}

	if rendered, err := executeFormatterTemplate("alarm_removed.tmpl", data); err == nil {
		return rendered
	}

	return f.fallbackAlarmRemoved(data)
}

func (f *ResponseFormatter) FormatAlarmList(alarms []AlarmListEntry) string {

	data := alarmListTemplateData{
		Count:  len(alarms),
		Prefix: f.prefix,
		Alarms: alarms,
	}

	if rendered, err := executeFormatterTemplate("alarm_list.tmpl", data); err == nil {
		return rendered
	}

	return f.fallbackAlarmList(data)
}

func (f *ResponseFormatter) FormatAlarmCleared(count int) string {

	data := alarmClearedTemplateData{Count: count}
	if rendered, err := executeFormatterTemplate("alarm_cleared.tmpl", data); err == nil {
		return rendered
	}

	if count == 0 {
		return "ÏÑ§Ï†ïÎêú ÏïåÎûåÏù¥ ÏóÜÏäµÎãàÎã§."
	}
	return fmt.Sprintf("‚úÖ %dÍ∞úÏùò ÏïåÎûåÏù¥ Î™®Îëê Ìï¥Ï†úÎêòÏóàÏäµÎãàÎã§.", count)
}

func (f *ResponseFormatter) FormatAlarmNotification(channel *domain.Channel, stream *domain.Stream, minutesUntil int, users []string) string {

	// Users are kept for dispatch logic; count is intentionally excluded from the message.
	_ = users

	channelName := ""
	if channel != nil {
		channelName = channel.GetDisplayName()
	}

	data := alarmNotificationTemplateData{
		ChannelName:  channelName,
		MinutesUntil: minutesUntil,
		Title:        util.TruncateString(stream.Title, constants.StringLimits.StreamTitle),
		URL:          stream.GetYouTubeURL(),
	}

	if rendered, err := executeFormatterTemplate("alarm_notification.tmpl", data); err == nil {
		return rendered
	}

	return f.fallbackAlarmNotification(data)
}

func (f *ResponseFormatter) FormatHelp() string {

	data := helpTemplateData{Prefix: f.prefix}
	if rendered, err := executeFormatterTemplate("help.tmpl", data); err == nil {
		return rendered
	}

	p := f.prefix
	return fmt.Sprintf(`üå∏ ÌôÄÎ°úÎùºÏù¥Î∏å Ïπ¥Ïπ¥Ïò§ÌÜ° Î¥á
	
	üì∫ Î∞©ÏÜ° ÌôïÏù∏
	  %sÎùºÏù¥Î∏å - ÌòÑÏû¨ ÎùºÏù¥Î∏å Ï§ëÏù∏ Î∞©ÏÜ°
	  %sÎùºÏù¥Î∏å [Î©§Î≤ÑÎ™Ö] - ÌäπÏ†ï Î©§Î≤Ñ ÎùºÏù¥Î∏å ÌôïÏù∏
	  %sÏòàÏ†ï [ÏãúÍ∞Ñ] - ÏòàÏ†ïÎêú Î∞©ÏÜ° (Í∏∞Î≥∏ 24ÏãúÍ∞Ñ)
	  %sÎ©§Î≤Ñ [Ïù¥Î¶Ñ] [ÏùºÏàò] - ÌäπÏ†ï Î©§Î≤Ñ ÏùºÏ†ï (Í∏∞Î≥∏ 7Ïùº)
	
	üë§ Î©§Î≤Ñ Ï†ïÎ≥¥
	  %sÏ†ïÎ≥¥ [Î©§Î≤ÑÎ™Ö] - Î©§Î≤Ñ ÌîÑÎ°úÌïÑ Ï°∞Ìöå
	  Ïòà: "%sÎØ∏ÏΩî Ï†ïÎ≥¥", "%sÏïÑÏø†ÏïÑÏóê ÎåÄÌï¥ ÏïåÎ†§Ï§ò"
	
	üîî ÏïåÎûå ÏÑ§Ï†ï
	  %sÏïåÎûå Ï∂îÍ∞Ä [Î©§Î≤ÑÎ™Ö]
	  %sÏïåÎûå Ï†úÍ±∞ [Î©§Î≤ÑÎ™Ö]
	  %sÏïåÎûå Î™©Î°ù
	  %sÏïåÎûå Ï¥àÍ∏∞Ìôî
	
	üìä ÌÜµÍ≥Ñ (NEW!)
	  %sÍµ¨ÎèÖÏûêÏàúÏúÑ - ÏßÄÎÇú 7Ïùº Íµ¨ÎèÖÏûê Ï¶ùÍ∞Ä ÏàúÏúÑ TOP 10
	  ÏûêÎèô ÏïåÎ¶º: ÎßàÏùºÏä§ÌÜ§ Îã¨ÏÑ± Ïãú (10Îßå, 100Îßå, 500Îßå Îì±)
	
	üí¨ ÏûêÏó∞Ïñ¥ ÏßÄÏõê
	  Ïòà: "%sÌéòÏΩîÎùº ÏùºÏ†ï ÏïåÎ†§Ï§ò", "%sÏßÄÍ∏à Î∞©ÏÜ°ÌïòÎäî ÏÇ¨Îûå ÏûàÏñ¥?"
	
	‚ù§Ô∏è Made with love for Hololive fans`, p, p, p, p, p, p, p, p, p, p, p, p, p, p)
}

func (f *ResponseFormatter) fallbackLiveStreams(data liveStreamsTemplateData) string {
	if data.Count == 0 {
		return "üî¥ ÌòÑÏû¨ Î∞©ÏÜ° Ï§ëÏù∏ Ïä§Ìä∏Î¶ºÏù¥ ÏóÜÏäµÎãàÎã§."
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("üî¥ ÌòÑÏû¨ ÎùºÏù¥Î∏å Ï§ë (%dÍ∞ú)\n\n", data.Count))

	for i, stream := range data.Streams {
		if i > 0 {
			sb.WriteString("\n")
		}

		sb.WriteString(fmt.Sprintf("üì∫ %s\n", stream.ChannelName))
		sb.WriteString(fmt.Sprintf("   %s\n", stream.Title))
		sb.WriteString(fmt.Sprintf("   %s", stream.URL))

		if i < data.Count-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

func (f *ResponseFormatter) fallbackUpcomingStreams(data upcomingStreamsTemplateData) string {
	if data.Count == 0 {
		return fmt.Sprintf("üìÖ %dÏãúÍ∞Ñ Ïù¥ÎÇ¥ ÏòàÏ†ïÎêú Î∞©ÏÜ°Ïù¥ ÏóÜÏäµÎãàÎã§.", data.Hours)
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("üìÖ ÏòàÏ†ïÎêú Î∞©ÏÜ° (%dÏãúÍ∞Ñ Ïù¥ÎÇ¥, %dÍ∞ú)\n\n", data.Hours, data.Count))

	for i, stream := range data.Streams {
		if i > 0 {
			sb.WriteString("\n")
		}

		sb.WriteString(fmt.Sprintf("üì∫ %s\n", stream.ChannelName))
		sb.WriteString(fmt.Sprintf("   %s\n", stream.Title))
		sb.WriteString(fmt.Sprintf("   ‚è∞ %s\n", stream.TimeInfo))
		sb.WriteString(fmt.Sprintf("   %s", stream.URL))

		if i < data.Count-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

func (f *ResponseFormatter) fallbackChannelSchedule(data channelScheduleTemplateData) string {
	if data.ChannelName == "" {
		return "‚ùå Ï±ÑÎÑê Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
	}

	if data.Count == 0 {
		return fmt.Sprintf("üìÖ %s\n%dÏùº Ïù¥ÎÇ¥ ÏòàÏ†ïÎêú Î∞©ÏÜ°Ïù¥ ÏóÜÏäµÎãàÎã§.", data.ChannelName, data.Days)
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("üìÖ %s ÏùºÏ†ï (%dÏùº Ïù¥ÎÇ¥, %dÍ∞ú)\n\n", data.ChannelName, data.Days, data.Count))

	for i, stream := range data.Streams {
		if i > 0 {
			sb.WriteString("\n")
		}

		sb.WriteString(fmt.Sprintf("%s %s\n", stream.StatusIcon, stream.Title))
		sb.WriteString(fmt.Sprintf("   %s\n", stream.TimeInfo))
		sb.WriteString(fmt.Sprintf("   %s", stream.URL))

		if i < data.Count-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

func (f *ResponseFormatter) fallbackAlarmAdded(data alarmAddedTemplateData) string {
	if !data.Added {
		return fmt.Sprintf("‚ÑπÔ∏è %s ÏïåÎûåÏù¥ Ïù¥ÎØ∏ ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏäµÎãàÎã§.", data.MemberName)
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("‚úÖ %s ÏïåÎûåÏù¥ ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§!\n\n", data.MemberName))
	if data.NextInfo != "" {
		sb.WriteString(data.NextInfo)
		if !strings.HasSuffix(data.NextInfo, "\n") {
			sb.WriteString("\n")
		}
		sb.WriteString("\n")
	}
	sb.WriteString("Î∞©ÏÜ° ÏãúÏûë 5Î∂Ñ Ï†ÑÏóê ÏïåÎ¶ºÏùÑ Î∞õÏäµÎãàÎã§.\n")
	sb.WriteString(fmt.Sprintf("%sÏïåÎûå Î™©Î°ù ÏúºÎ°ú ÌôïÏù∏ Í∞ÄÎä•Ìï©ÎãàÎã§.", f.prefix))
	return sb.String()
}

func (f *ResponseFormatter) fallbackAlarmRemoved(data alarmRemovedTemplateData) string {
	if data.Removed {
		return fmt.Sprintf("‚úÖ %s ÏïåÎûåÏù¥ Ìï¥Ï†úÎêòÏóàÏäµÎãàÎã§.", data.MemberName)
	}
	return fmt.Sprintf("‚ùå %s ÏïåÎûåÏù¥ ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.", data.MemberName)
}

func (f *ResponseFormatter) fallbackAlarmList(data alarmListTemplateData) string {
	if data.Count == 0 {
		return fmt.Sprintf(`üîî ÏÑ§Ï†ïÎêú ÏïåÎûåÏù¥ ÏóÜÏäµÎãàÎã§.

üí° ÏÇ¨Ïö©Î≤ï:
%[1]sÏïåÎûå Ï∂îÍ∞Ä [Î©§Î≤ÑÎ™Ö]
Ïòà) %[1]sÏïåÎûå Ï∂îÍ∞Ä ÌéòÏΩîÎùº
Ïòà) %[1]sÏïåÎûå Ï∂îÍ∞Ä ÎØ∏ÏΩî`, data.Prefix)
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("üîî ÏÑ§Ï†ïÎêú ÏïåÎûå (%dÍ∞ú)\n\n", data.Count))

	for idx, alarm := range data.Alarms {
		sb.WriteString(fmt.Sprintf("%d. %s\n", idx+1, alarm.MemberName))
		if strings.TrimSpace(alarm.NextStream) != "" {
			sb.WriteString(fmt.Sprintf("   %s\n", alarm.NextStream))
		}
		sb.WriteString("\n")
	}

	sb.WriteString(fmt.Sprintf("üí° %sÏïåÎûå Ï†úÍ±∞ [Î©§Î≤ÑÎ™Ö] ÏúºÎ°ú ÏïåÎûå Ìï¥Ï†ú", data.Prefix))
	return strings.TrimSuffix(sb.String(), "\n")
}

func (f *ResponseFormatter) fallbackAlarmNotification(data alarmNotificationTemplateData) string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("üîî %s Î∞©ÏÜ° ÏïåÎ¶º\n\n", data.ChannelName))

	if data.MinutesUntil > 0 {
		sb.WriteString(fmt.Sprintf("‚è∞ %dÎ∂Ñ ÌõÑ ÏãúÏûë ÏòàÏ†ï\n", data.MinutesUntil))
	} else {
		sb.WriteString("‚è∞ Í≥ß ÏãúÏûëÌï©ÎãàÎã§!\n")
	}

	sb.WriteString(fmt.Sprintf("\nüì∫ %s\n\n", data.Title))
	sb.WriteString(data.URL)
	return sb.String()
}

func (f *ResponseFormatter) FormatError(message string) string {
	return fmt.Sprintf("‚ùå %s", message)
}

func (f *ResponseFormatter) FormatMemberNotFound(memberName string) string {
	return f.FormatError(fmt.Sprintf("'%s' Î©§Î≤ÑÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", memberName))
}

func (f *ResponseFormatter) FormatTalentProfile(raw *domain.TalentProfile, translated *domain.Translated) string {
	if raw == nil {
		return "‚ùå ÌîÑÎ°úÌïÑ Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
	}

	var sb strings.Builder

	displayName := raw.EnglishName
	if translated != nil && strings.TrimSpace(translated.DisplayName) != "" {
		displayName = translated.DisplayName
	}

	sb.WriteString(fmt.Sprintf("üìò %s", displayName))
	if raw.JapaneseName != "" {
		sb.WriteString(fmt.Sprintf(" (%s)", raw.JapaneseName))
	}
	sb.WriteString("\n")

	catchphrase := strings.TrimSpace(raw.Catchphrase)
	if translated != nil && strings.TrimSpace(translated.Catchphrase) != "" {
		catchphrase = translated.Catchphrase
	}
	if catchphrase != "" {
		sb.WriteString(fmt.Sprintf("üó£Ô∏è %s\n", catchphrase))
	}

	summary := ""
	if translated != nil && strings.TrimSpace(translated.Summary) != "" {
		summary = translated.Summary
	} else if raw.Description != "" {
		summary = raw.Description
	}
	if summary != "" {
		sb.WriteString(summary)
		sb.WriteString("\n")
	}

	if translated != nil && len(translated.Highlights) > 0 {
		sb.WriteString("\n‚ú® ÌïòÏù¥ÎùºÏù¥Ìä∏\n")
		for _, highlight := range translated.Highlights {
			trimmed := strings.TrimSpace(highlight)
			if trimmed == "" {
				continue
			}
			sb.WriteString(fmt.Sprintf("- %s\n", trimmed))
		}
	}

	dataEntries := make([]domain.TranslatedProfileDataRow, 0)
	if translated != nil && len(translated.Data) > 0 {
		dataEntries = translated.Data
	} else {
		for _, entry := range raw.DataEntries {
			if strings.TrimSpace(entry.Label) == "" || strings.TrimSpace(entry.Value) == "" {
				continue
			}
			dataEntries = append(dataEntries, domain.TranslatedProfileDataRow{
				Label: entry.Label,
				Value: entry.Value,
			})
		}
	}

	if len(dataEntries) > 0 {
		sb.WriteString("\nüìã ÌîÑÎ°úÌïÑ Îç∞Ïù¥ÌÑ∞\n")
		maxRows := len(dataEntries)
		if maxRows > 8 {
			maxRows = 8
		}
		for i := 0; i < maxRows; i++ {
			row := dataEntries[i]
			if strings.TrimSpace(row.Label) == "" || strings.TrimSpace(row.Value) == "" {
				continue
			}
			sb.WriteString(fmt.Sprintf("- %s: %s\n", row.Label, row.Value))
		}
	}

	if len(raw.SocialLinks) > 0 {
		sb.WriteString("\nüîó ÎßÅÌÅ¨\n")
		maxLinks := len(raw.SocialLinks)
		if maxLinks > 4 {
			maxLinks = 4
		}
		for i := 0; i < maxLinks; i++ {
			link := raw.SocialLinks[i]
			if strings.TrimSpace(link.Label) == "" || strings.TrimSpace(link.URL) == "" {
				continue
			}
			translatedLabel := translateSocialLinkLabel(link.Label)
			sb.WriteString(fmt.Sprintf("- %s: %s\n", translatedLabel, link.URL))
		}
	}

	if raw.OfficialURL != "" {
		sb.WriteString("\nüåê Í≥µÏãù ÌîÑÎ°úÌïÑ: ")
		sb.WriteString(raw.OfficialURL)
	}

	return strings.TrimSpace(sb.String())
}

func translateSocialLinkLabel(label string) string {
	translations := map[string]string{
		"Ê≠å„ÅÆÂÜçÁîü„É™„Çπ„Éà":   "ÏùåÏïÖ ÌîåÎ†àÏù¥Î¶¨Ïä§Ìä∏",
		"ÂÖ¨Âºè„Ç∞„ÉÉ„Ç∫":     "Í≥µÏãù ÍµøÏ¶à",
		"„Ç™„Éï„Ç£„Ç∑„É£„É´„Ç∞„ÉÉ„Ç∫": "Í≥µÏãù ÍµøÏ¶à",
	}

	if korean, ok := translations[label]; ok {
		return korean
	}
	return label
}

func (f *ResponseFormatter) truncateTitle(title string) string {
	return util.TruncateString(title, constants.StringLimits.StreamTitle)
}

func (f *ResponseFormatter) formatStreamTimeInfo(stream *domain.Stream) string {
	if stream == nil || stream.StartScheduled == nil {
		return "ÏãúÍ∞Ñ ÎØ∏Ï†ï"
	}

	kstTime := util.FormatKST(*stream.StartScheduled, "01/02 15:04")
	minutesUntil := stream.MinutesUntilStart()

	if minutesUntil <= 0 {
		return kstTime
	}

	hoursUntil := minutesUntil / 60
	minutesRem := minutesUntil % 60

	if hoursUntil > 24 {
		daysUntil := hoursUntil / 24
		return fmt.Sprintf("%s (%dÏùº ÌõÑ)", kstTime, daysUntil)
	} else if hoursUntil > 0 {
		return fmt.Sprintf("%s (%dÏãúÍ∞Ñ %dÎ∂Ñ ÌõÑ)", kstTime, hoursUntil, minutesRem)
	} else {
		return fmt.Sprintf("%s (%dÎ∂Ñ ÌõÑ)", kstTime, minutesRem)
	}
}
